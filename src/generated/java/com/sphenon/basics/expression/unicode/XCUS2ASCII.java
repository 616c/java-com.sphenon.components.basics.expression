/* Generated By:JavaCC: Do not edit this line. XCUS2ASCII.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.basics.expression.unicode;

import com.sphenon.basics.context.*;
import com.sphenon.basics.expression.*;
import com.sphenon.basics.expression.classes.*;

import java.io.BufferedReader;
import java.io.StringReader;
import java.io.Reader;
import java.io.Writer;
import java.io.IOException;

public class XCUS2ASCII implements XCUS2ASCIIConstants {

  static protected XCUS2ASCII parser;

  static synchronized public String parse(CallContext context, String string, String mode) throws ParseException {
      if (parser == null) {
          parser = new XCUS2ASCII(context, string, mode);
      } else {
          parser.ReInit(context, string, mode);
      }
      return parser.XCUS();
  }

  protected boolean expr;
  protected boolean pgm;
  protected boolean js;

  protected void setMode(CallContext context, String mode) {
      expr = false;
      pgm = false;
      js = false;
      switch (mode) {
          case "pgm" : pgm = true; break;
          case "js"  : js  = true; break;
          default    : expr = true;
      }
  }

  public XCUS2ASCII (CallContext context, String expression, String mode) {
      this(new BufferedReader(new StringReader(expression)));
      setMode(context, mode);
  }

  public void ReInit (CallContext context, String expression, String mode) {
      ReInit(new BufferedReader(new StringReader(expression)));
      setMode(context, mode);
  }

  public String getPosition(CallContext context) {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public void Token(StringBuilder out) throws ParseException {
                                  Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCAPE:
      token = jj_consume_token(ESCAPE);
                             out.append(token.image.charAt(1));
      break;
    case CMTBEGIN:
      jj_consume_token(CMTBEGIN);
                             out.append("#*");
      break;
    case CMTEND:
      jj_consume_token(CMTEND);
                             out.append("*#");
      break;
    case EXPRBEGIN:
      jj_consume_token(EXPRBEGIN);
                             out.append("`{");
      break;
    case EXPREND:
      jj_consume_token(EXPREND);
                             out.append("}`");
      break;
    case UNICODE:
      token = jj_consume_token(UNICODE);
                             out.append(token.image.substring(1,token.image.length()-1).replaceAll("\\\u2034", "\u2034").replaceAll("\\\\","\\"));
      break;
    case OORL:
      OORL(out);
      break;
    case EXPRB:
      Expression(out);
      break;
    case BASH:
      jj_consume_token(BASH);
                             out.append("bash");
      break;
    case SHELL:
      jj_consume_token(SHELL);
                             out.append("shell");
      break;
    case SCOPE:
      jj_consume_token(SCOPE);
                             out.append("scope");
      break;
    case JAVASCRIPT:
      jj_consume_token(JAVASCRIPT);
                             out.append("js");
      break;
    case OPERATION:
      jj_consume_token(OPERATION);
                             out.append("operation");
      break;
    case PROGRAM:
      jj_consume_token(PROGRAM);
                             out.append("program");
      break;
    case PROCESS:
      jj_consume_token(PROCESS);
                             out.append("process");
      break;
    case PLACEHOLDER:
      jj_consume_token(PLACEHOLDER);
                             out.append("placeholder");
      break;
    case MULTIITER:
      jj_consume_token(MULTIITER);
                             out.append("multiiterator");
      break;
    case MULTITIMES:
      jj_consume_token(MULTITIMES);
                             out.append("!*!");
      break;
    case EQUALS:
      jj_consume_token(EQUALS);
                             out.append(".equals");
      break;
    case RECODING:
      jj_consume_token(RECODING);
                             out.append("%%");
      break;
    case CONFIG:
      jj_consume_token(CONFIG);
                             out.append("\u00b0\u00b0");
      break;
    case OR:
      jj_consume_token(OR);
                             out.append("||");
      break;
    case AND:
      jj_consume_token(AND);
                             out.append(js ? "&amp;&amp;" : "&&");
      break;
    case ULT:
      jj_consume_token(ULT);
                             out.append("<");
      break;
    case UGT:
      jj_consume_token(UGT);
                             out.append(">");
      break;
    case UNULL:
      jj_consume_token(UNULL);
                             out.append("null");
      break;
    case UTRUE:
      jj_consume_token(UTRUE);
                             out.append("true");
      break;
    case UFALSE:
      jj_consume_token(UFALSE);
                             out.append("false");
      break;
    case UQUOTE:
      jj_consume_token(UQUOTE);
                             out.append("\"");
      break;
    case TIME:
      jj_consume_token(TIME);
                             out.append("com.sphenon.basics.system.SystemUtilities.getDate(context, ");
      break;
    case FORMAT:
      jj_consume_token(FORMAT);
                             out.append("com.sphenon.basics.system.SystemUtilities.format(context, ");
      break;
    case SIZE:
      jj_consume_token(SIZE);
                             out.append("com.sphenon.basics.system.MathUtilities.size(context, ");
      break;
    case AVERAGE:
      jj_consume_token(AVERAGE);
                             out.append("com.sphenon.basics.system.MathUtilities.average(context, ");
      break;
    case PRODUCT:
      jj_consume_token(PRODUCT);
                             out.append("com.sphenon.basics.system.MathUtilities.product(context, ");
      break;
    case SUM:
      jj_consume_token(SUM);
                             out.append("com.sphenon.basics.system.MathUtilities.sum(context, ");
      break;
    case MINIMUM:
      jj_consume_token(MINIMUM);
                             out.append("com.sphenon.basics.system.MathUtilities.minimum(context, ");
      break;
    case MAXIMUM:
      jj_consume_token(MAXIMUM);
                             out.append("com.sphenon.basics.system.MathUtilities.maximum(context, ");
      break;
    case SELECT:
      jj_consume_token(SELECT);
                             out.append("shell:select ");
      break;
    case REQUIRE:
      jj_consume_token(REQUIRE);
                             out.append("shell:require ");
      break;
    case SCRIPT:
      jj_consume_token(SCRIPT);
                             out.append("shell:process ");
      break;
    case PREPROCESS:
      jj_consume_token(PREPROCESS);
                             out.append("shell:preprocess ");
      break;
    case EXECUTE:
      jj_consume_token(EXECUTE);
                             out.append("execute");
      break;
    case BEGINPROC:
      jj_consume_token(BEGINPROC);
                             out.append("begin procedure");
      break;
    case ENDPROC:
      jj_consume_token(ENDPROC);
                             out.append("end procedure");
      break;
    case BEGINBLK:
      jj_consume_token(BEGINBLK);
                             out.append("begin block");
      break;
    case ENDBLK:
      jj_consume_token(ENDBLK);
                             out.append("end block");
      break;
    case SEPARATOR:
      jj_consume_token(SEPARATOR);
                             out.append(";;");
      break;
    case CMTB:
      jj_consume_token(CMTB);
                             if (pgm) { out.append("\\/*"); }
                             else     { out.append("/*");   }
      break;
    case CMTE:
      jj_consume_token(CMTE);
                             if (pgm) { out.append("*\\/"); }
                             else     { out.append("*/");   }
      break;
    case BTICK:
      jj_consume_token(BTICK);
                             if (pgm) { out.append("\\`"); }
                             else     { out.append("`");   }
      break;
    case BACKSL:
      jj_consume_token(BACKSL);
                             if (pgm) { out.append("\\\\"); }
                             else     { out.append("\\");   }
      break;
    case NEWLINE:
      jj_consume_token(NEWLINE);
                             out.append("\\n");
      break;
    case CONT:
      jj_consume_token(CONT);
                             out.append("\\");
      break;
    case CONTPLUS:
      jj_consume_token(CONTPLUS);
                             out.append("\\+");
      break;
    case ANY:
      token = jj_consume_token(ANY);
                             out.append(token.image);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OORLToken(StringBuilder out) throws ParseException {
                                      Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OXPATH:
      jj_consume_token(OXPATH);
                     out.append("XPath");
      break;
    case OPROPERTY:
      jj_consume_token(OPROPERTY);
                     out.append("Property");
      break;
    case OXMODEL:
      jj_consume_token(OXMODEL);
                     out.append("XModel");
      break;
    case OFILE:
      jj_consume_token(OFILE);
                     out.append("File");
      break;
    case OSQL:
      jj_consume_token(OSQL);
                     out.append("SQL");
      break;
    case OANY:
      token = jj_consume_token(OANY);
                     out.append(token.image);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OORL(StringBuilder out) throws ParseException {
                                 Token token=null;
    jj_consume_token(OORL);
                                              out.append(js ? "::" : "oorl:");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OLT:
      jj_consume_token(OLT);
      token = jj_consume_token(OIDENTIFIER);
      jj_consume_token(OGT);
                                              out.append("<").append(token.image).append(">");
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OOPBRK:
      jj_consume_token(OOPBRK);
      token = jj_consume_token(OIDENTIFIER);
      jj_consume_token(OCLBRK);
                                              out.append("[").append(token.image).append("]");
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ODELDQB:
      token = jj_consume_token(ODELDQB);
                                    if (js) { out.append(token.image); }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH:
        case OPROPERTY:
        case OXMODEL:
        case OFILE:
        case OSQL:
        case OANY:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_1;
        }
        OORLToken(out);
      }
      token = jj_consume_token(ODELDQE);
                                    if (js) { out.append(token.image); }
      break;
    case ODELSQB:
      token = jj_consume_token(ODELSQB);
                                    if (js) { out.append(token.image); }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH:
        case OPROPERTY:
        case OXMODEL:
        case OFILE:
        case OSQL:
        case OANY:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_2;
        }
        OORLToken(out);
      }
      token = jj_consume_token(ODELSQE);
                                    if (js) { out.append(token.image); }
      break;
    case ODELBCB:
      token = jj_consume_token(ODELBCB);
                                    if (js) { out.append(token.image); }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH:
        case OPROPERTY:
        case OXMODEL:
        case OFILE:
        case OSQL:
        case OANY:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
        OORLToken(out);
      }
      token = jj_consume_token(ODELBCE);
                                    if (js) { out.append(token.image); }
      break;
    case ODELPAB:
      token = jj_consume_token(ODELPAB);
                                    if (js) { out.append(token.image); }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH:
        case OPROPERTY:
        case OXMODEL:
        case OFILE:
        case OSQL:
        case OANY:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        OORLToken(out);
      }
      token = jj_consume_token(ODELPAE);
                                    if (js) { out.append(token.image); }
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Expression(StringBuilder out) throws ParseException {
                                       Token token=null;
    jj_consume_token(EXPRB);
                             out.append("{*");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELT:
      jj_consume_token(ELT);
                             out.append("<");
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(EGT);
                             out.append(">");
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOPBRK:
      jj_consume_token(EOPBRK);
                             out.append("[");
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(ECLBRK);
                             out.append("]");
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
                             out.append("unicode,evaluate:");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANYEXPR:
      token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELT:
        case EGT:
        case EOPBRK:
        case ECLBRK:
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_7;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELT:
          jj_consume_token(ELT);
                             out.append("<");
          break;
        case EGT:
          jj_consume_token(EGT);
                             out.append(">");
          break;
        case EOPBRK:
          jj_consume_token(EOPBRK);
                             out.append("[");
          break;
        case ECLBRK:
          jj_consume_token(ECLBRK);
                             out.append("]");
          break;
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(EXPRE);
                             out.append("*}");
  }

  final public void Line(StringBuilder out) throws ParseException {
                                 Token token=null;
    Token(out);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCAPE:
      case CONT:
      case CONTPLUS:
      case LNINDT:
      case SEPARATOR:
      case UNICODE:
      case WS:
      case SELECT:
      case REQUIRE:
      case SCRIPT:
      case PREPROCESS:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case OORL:
      case BASH:
      case SHELL:
      case SCOPE:
      case JAVASCRIPT:
      case OPERATION:
      case PROGRAM:
      case PROCESS:
      case PLACEHOLDER:
      case MULTIITER:
      case MULTITIMES:
      case EQUALS:
      case RECODING:
      case CONFIG:
      case OR:
      case AND:
      case ULT:
      case UGT:
      case UNULL:
      case UTRUE:
      case UFALSE:
      case UQUOTE:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case EXPRB:
      case EXECUTE:
      case BEGINPROC:
      case ENDPROC:
      case BEGINBLK:
      case ENDBLK:
      case CMTB:
      case CMTE:
      case BTICK:
      case BACKSL:
      case NEWLINE:
      case ANY:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                               out.append(token.image);
        break;
      case LNINDT:
        jj_consume_token(LNINDT);
                               out.append(token.image);
        break;
      case ESCAPE:
      case CONT:
      case CONTPLUS:
      case SEPARATOR:
      case UNICODE:
      case SELECT:
      case REQUIRE:
      case SCRIPT:
      case PREPROCESS:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case OORL:
      case BASH:
      case SHELL:
      case SCOPE:
      case JAVASCRIPT:
      case OPERATION:
      case PROGRAM:
      case PROCESS:
      case PLACEHOLDER:
      case MULTIITER:
      case MULTITIMES:
      case EQUALS:
      case RECODING:
      case CONFIG:
      case OR:
      case AND:
      case ULT:
      case UGT:
      case UNULL:
      case UTRUE:
      case UFALSE:
      case UQUOTE:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case EXPRB:
      case EXECUTE:
      case BEGINPROC:
      case ENDPROC:
      case BEGINBLK:
      case ENDBLK:
      case CMTB:
      case CMTE:
      case BTICK:
      case BACKSL:
      case NEWLINE:
      case ANY:
        Token(out);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void LeadingSpace(StringBuilder out) throws ParseException {
                                         Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      token = jj_consume_token(WS);
                             out.append(token.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNINDT:
        jj_consume_token(LNINDT);
                             out.append("<%|");
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          token = jj_consume_token(WS);
                             out.append(token.image);
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      break;
    case LNINDT:
      jj_consume_token(LNINDT);
                             out.append("<%|");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                             out.append(token.image);
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NewLine(StringBuilder out) throws ParseException {
                                    Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LNCONT:
      jj_consume_token(LNCONT);
                           out.append("\\\n");
      break;
    case LNCONTPLUS:
      jj_consume_token(LNCONTPLUS);
                           out.append("\\+\n");
      break;
    case LN:
      jj_consume_token(LN);
                           out.append("\n");
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String XCUS() throws ParseException {
                  Token token=null;
    StringBuilder out = new StringBuilder();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LNINDT:
    case WS:
      LeadingSpace(out);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCAPE:
    case CONT:
    case CONTPLUS:
    case SEPARATOR:
    case UNICODE:
    case SELECT:
    case REQUIRE:
    case SCRIPT:
    case PREPROCESS:
    case CMTBEGIN:
    case CMTEND:
    case EXPRBEGIN:
    case EXPREND:
    case OORL:
    case BASH:
    case SHELL:
    case SCOPE:
    case JAVASCRIPT:
    case OPERATION:
    case PROGRAM:
    case PROCESS:
    case PLACEHOLDER:
    case MULTIITER:
    case MULTITIMES:
    case EQUALS:
    case RECODING:
    case CONFIG:
    case OR:
    case AND:
    case ULT:
    case UGT:
    case UNULL:
    case UTRUE:
    case UFALSE:
    case UQUOTE:
    case TIME:
    case FORMAT:
    case SIZE:
    case AVERAGE:
    case PRODUCT:
    case SUM:
    case MINIMUM:
    case MAXIMUM:
    case EXPRB:
    case EXECUTE:
    case BEGINPROC:
    case ENDPROC:
    case BEGINBLK:
    case ENDBLK:
    case CMTB:
    case CMTE:
    case BTICK:
    case BACKSL:
    case NEWLINE:
    case ANY:
      Line(out);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNCONT:
      case LNCONTPLUS:
      case LN:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_9;
      }
      NewLine(out);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNINDT:
      case WS:
        LeadingSpace(out);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCAPE:
      case CONT:
      case CONTPLUS:
      case SEPARATOR:
      case UNICODE:
      case SELECT:
      case REQUIRE:
      case SCRIPT:
      case PREPROCESS:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case OORL:
      case BASH:
      case SHELL:
      case SCOPE:
      case JAVASCRIPT:
      case OPERATION:
      case PROGRAM:
      case PROCESS:
      case PLACEHOLDER:
      case MULTIITER:
      case MULTITIMES:
      case EQUALS:
      case RECODING:
      case CONFIG:
      case OR:
      case AND:
      case ULT:
      case UGT:
      case UNULL:
      case UTRUE:
      case UFALSE:
      case UQUOTE:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case EXPRB:
      case EXECUTE:
      case BEGINPROC:
      case ENDPROC:
      case BEGINBLK:
      case ENDBLK:
      case CMTB:
      case CMTE:
      case BTICK:
      case BACKSL:
      case NEWLINE:
      case ANY:
        Line(out);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
    }
    jj_consume_token(0);
    {if (true) return out.toString();}
    throw new Error("Missing return statement in function");
  }

  public XCUS2ASCIITokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[30];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xfffff9b2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffffbf2,0xfffffbf2,0x200,0x40,0x200,0x240,0x40c,0x240,0xfffff9b2,0x40c,0x240,0xfffff9b2,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x1fffffff,0x0,0x80000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fffffff,0x1fffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x1fffffff,0x0,0x0,0x1fffffff,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x1f800,0x0,0x0,0x1f800,0x1f800,0x1f800,0x1f800,0x78,0xc00000,0xc00000,0x20000,0xc00000,0xc00000,0x80000,0xde0000,0xde0000,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  public XCUS2ASCII(java.io.InputStream stream) {
     this(stream, null);
  }
  public XCUS2ASCII(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new XCUS2ASCIITokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  public XCUS2ASCII(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XCUS2ASCIITokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  public XCUS2ASCII(XCUS2ASCIITokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  public void ReInit(XCUS2ASCIITokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[88];
    for (int i = 0; i < 88; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 30; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 88; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
