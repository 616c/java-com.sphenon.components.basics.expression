/* Generated By:JavaCC: Do not edit this line. XCUS2ASCII.java */
package com.sphenon.basics.expression.unicode;

import com.sphenon.basics.context.*;
import com.sphenon.basics.expression.*;
import com.sphenon.basics.expression.classes.*;

import java.io.BufferedReader;
import java.io.StringReader;
import java.io.Reader;
import java.io.Writer;
import java.io.IOException;

public class XCUS2ASCII implements XCUS2ASCIIConstants {

  static protected XCUS2ASCII parser;

  static synchronized public String parse(CallContext context, String string, String mode) throws ParseException {
      if (parser == null) {
          parser = new XCUS2ASCII(context, string, mode);
      } else {
          parser.ReInit(context, string, mode);
      }
      return parser.XCUS();
  }

  protected boolean expr;
  protected boolean pgm;
  protected boolean js;

  protected void setMode(CallContext context, String mode) {
      expr = false;
      pgm = false;
      js = false;
      switch (mode) {
          case "pgm" : pgm = true; break;
          case "js"  : js  = true; break;
          default    : expr = true;
      }
  }

  public XCUS2ASCII (CallContext context, String expression, String mode) {
      this(new BufferedReader(new StringReader(expression)));
      setMode(context, mode);
  }

  public void ReInit (CallContext context, String expression, String mode) {
      ReInit(new BufferedReader(new StringReader(expression)));
      setMode(context, mode);
  }

  public String getPosition(CallContext context) {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public void Token(StringBuilder out) throws ParseException {
                                  Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCAPE:
      token = jj_consume_token(ESCAPE);
                             out.append(token.image.charAt(1));
      break;
    case CMTBEGIN:
      jj_consume_token(CMTBEGIN);
                             out.append("#*");
      break;
    case CMTEND:
      jj_consume_token(CMTEND);
                             out.append("*#");
      break;
    case EXPRBEGIN:
      jj_consume_token(EXPRBEGIN);
                             out.append("`{");
      break;
    case EXPREND:
      jj_consume_token(EXPREND);
                             out.append("}`");
      break;
    case UNICODEESC:
      token = jj_consume_token(UNICODEESC);
                             out.append(token.image.substring(1,token.image.length()-1).replaceAll("\u005c\u005c\u2034", "\u2034").replaceAll("\u005c\u005c\u005c\u005c","\u005c\u005c"));
      break;
    case OORL:
      OORL(out);
      break;
    case EXPRB:
      Expression(out);
      break;
    case BASH:
      jj_consume_token(BASH);
                             out.append("bash");
      break;
    case SHELL:
      jj_consume_token(SHELL);
                             out.append("shell");
      break;
    case SCOPE:
      jj_consume_token(SCOPE);
                             out.append("scope");
      break;
    case JAVASCRIPT:
      jj_consume_token(JAVASCRIPT);
                             out.append("js");
      break;
    case OPERATION:
      jj_consume_token(OPERATION);
                             out.append("operation");
      break;
    case PROGRAM:
      jj_consume_token(PROGRAM);
                             out.append("program");
      break;
    case UNICODE:
      jj_consume_token(UNICODE);
                             out.append("unicode");
      break;
    case PROCESS:
      jj_consume_token(PROCESS);
                             out.append("process");
      break;
    case EVALUATE:
      jj_consume_token(EVALUATE);
                             out.append("evaluate");
      break;
    case CONTROL:
      jj_consume_token(CONTROL);
                             out.append("control");
      break;
    case CHECK:
      jj_consume_token(CHECK);
                             out.append("check");
      break;
    case LOG:
      jj_consume_token(LOG);
                             out.append("log");
      break;
    case PLACEHOLDER:
      jj_consume_token(PLACEHOLDER);
                             out.append("placeholder");
      break;
    case OCP:
      jj_consume_token(OCP);
                             out.append("ocp");
      break;
    case MULTIITER:
      jj_consume_token(MULTIITER);
                             out.append("multiiterator");
      break;
    case MULTITIMES:
      jj_consume_token(MULTITIMES);
                             out.append("!*!");
      break;
    case EQUALS:
      jj_consume_token(EQUALS);
                             out.append(".equals");
      break;
    case RECODING:
      jj_consume_token(RECODING);
                             out.append("%%");
      break;
    case JOIN:
      jj_consume_token(JOIN);
                             out.append("com.sphenon.basics.system.SystemUtilities.join(context, ");
      break;
    case EJOIN:
      jj_consume_token(EJOIN);
                             out.append(")");
      break;
    case CONFIG:
      jj_consume_token(CONFIG);
                             out.append("\u00b0\u00b0");
      break;
    case ENVIRONMENT:
      jj_consume_token(ENVIRONMENT);
                             out.append("java.lang.System.getenv(");
      break;
    case OR:
      jj_consume_token(OR);
                             out.append("||");
      break;
    case AND:
      jj_consume_token(AND);
                             out.append(js ? "&amp;&amp;" : "&&");
      break;
    case ULT:
      jj_consume_token(ULT);
                             out.append("<");
      break;
    case UGT:
      jj_consume_token(UGT);
                             out.append(">");
      break;
    case UNULLSTRING:
      jj_consume_token(UNULLSTRING);
                             out.append("com.sphenon.basics.system.StringUtilities.nullString");
      break;
    case UEMPTYSTRING:
      jj_consume_token(UEMPTYSTRING);
                             out.append("com.sphenon.basics.system.StringUtilities.emptyString");
      break;
    case UNULL:
      jj_consume_token(UNULL);
                             out.append("null");
      break;
    case UTRUE:
      jj_consume_token(UTRUE);
                             out.append("true");
      break;
    case UFALSE:
      jj_consume_token(UFALSE);
                             out.append("false");
      break;
    case UQUOTE:
      jj_consume_token(UQUOTE);
                             out.append("\u005c"");
      break;
    case FORMATDATE:
      jj_consume_token(FORMATDATE);
                             out.append("com.sphenon.basics.system.SystemUtilities.getDate(context, ");
      break;
    case FORMAT:
      jj_consume_token(FORMAT);
                             out.append("com.sphenon.basics.system.SystemUtilities.format(context, ");
      break;
    case TIME:
      jj_consume_token(TIME);
                             out.append("time");
      break;
    case DATE:
      jj_consume_token(DATE);
                             out.append("date");
      break;
    case DATETIME:
      jj_consume_token(DATETIME);
                             out.append("datetime");
      break;
    case SIZE:
      jj_consume_token(SIZE);
                             out.append("com.sphenon.basics.system.MathUtilities.size(context, ");
      break;
    case AVERAGE:
      jj_consume_token(AVERAGE);
                             out.append("com.sphenon.basics.system.MathUtilities.average(context, ");
      break;
    case PRODUCT:
      jj_consume_token(PRODUCT);
                             out.append("com.sphenon.basics.system.MathUtilities.product(context, ");
      break;
    case SUM:
      jj_consume_token(SUM);
                             out.append("com.sphenon.basics.system.MathUtilities.sum(context, ");
      break;
    case MINIMUM:
      jj_consume_token(MINIMUM);
                             out.append("com.sphenon.basics.system.MathUtilities.minimum(context, ");
      break;
    case MAXIMUM:
      jj_consume_token(MAXIMUM);
                             out.append("com.sphenon.basics.system.MathUtilities.maximum(context, ");
      break;
    case RECODEBS:
      jj_consume_token(RECODEBS);
                             out.append("com.sphenon.basics.encoding.Encoding.recodeByString(context, ");
      break;
    case RECODE:
      jj_consume_token(RECODE);
                             out.append("com.sphenon.basics.encoding.Encoding.recode(context, ");
      break;
    case ENCODING:
      jj_consume_token(ENCODING);
                             out.append("com.sphenon.basics.encoding.Encoding.");
      break;
    case DECORATE:
      jj_consume_token(DECORATE);
                             out.append("com.sphenon.basics.system.StringUtilities.decorate(context, ");
      break;
    case SELECT:
      jj_consume_token(SELECT);
                             out.append("shell:select ");
      break;
    case REQUIRE:
      jj_consume_token(REQUIRE);
                             out.append("shell:require ");
      break;
    case SCRIPT:
      jj_consume_token(SCRIPT);
                             out.append("shell:process ");
      break;
    case PREPROCESS:
      jj_consume_token(PREPROCESS);
                             out.append("shell:preprocess ");
      break;
    case EXECUTE:
      jj_consume_token(EXECUTE);
                             out.append("execute");
      break;
    case BEGINPROC:
      jj_consume_token(BEGINPROC);
                             out.append("begin procedure");
      break;
    case ENDPROC:
      jj_consume_token(ENDPROC);
                             out.append("end procedure");
      break;
    case BEGINBLK:
      jj_consume_token(BEGINBLK);
                             out.append("begin block");
      break;
    case ENDBLK:
      jj_consume_token(ENDBLK);
                             out.append("end block");
      break;
    case SEPARATOR:
      jj_consume_token(SEPARATOR);
                             out.append(";;");
      break;
    case CMTB:
      jj_consume_token(CMTB);
                             if (pgm) { out.append("\u005c\u005c/*"); }
                             else     { out.append("/*");   }
      break;
    case CMTE:
      jj_consume_token(CMTE);
                             if (pgm) { out.append("*\u005c\u005c/"); }
                             else     { out.append("*/");   }
      break;
    case BTICK:
      jj_consume_token(BTICK);
                             if (pgm) { out.append("\u005c\u005c`"); }
                             else     { out.append("`");   }
      break;
    case BACKSL:
      jj_consume_token(BACKSL);
                             if (pgm) { out.append("\u005c\u005c\u005c\u005c"); }
                             else     { out.append("\u005c\u005c");   }
      break;
    case NEWLINE:
      jj_consume_token(NEWLINE);
                             out.append("\u005c\u005cn");
      break;
    case CONT:
      jj_consume_token(CONT);
                             out.append("\u005c\u005c");
      break;
    case CONTPLUS:
      jj_consume_token(CONTPLUS);
                             out.append("\u005c\u005c+");
      break;
    case ANY:
      token = jj_consume_token(ANY);
                             out.append(token.image);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OORLToken(StringBuilder out) throws ParseException {
                                      Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OXPATH:
      jj_consume_token(OXPATH);
                     out.append("XPath");
      break;
    case OPROPERTY:
      jj_consume_token(OPROPERTY);
                     out.append("Property");
      break;
    case OXMODEL:
      jj_consume_token(OXMODEL);
                     out.append("XModel");
      break;
    case OFILE:
      jj_consume_token(OFILE);
                     out.append("File");
      break;
    case OSQL:
      jj_consume_token(OSQL);
                     out.append("SQL");
      break;
    case OANY:
      token = jj_consume_token(OANY);
                     out.append(token.image);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OORL(StringBuilder out) throws ParseException {
                                 Token token=null;
    jj_consume_token(OORL);
                                              out.append(js ? "::" : "oorl:");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OLT:
      jj_consume_token(OLT);
      token = jj_consume_token(OIDENTIFIER);
      jj_consume_token(OGT);
                                              out.append("<").append(token.image).append(">");
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OOPBRK:
      jj_consume_token(OOPBRK);
      token = jj_consume_token(OIDENTIFIER);
      jj_consume_token(OCLBRK);
                                              out.append("[").append(token.image).append("]");
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ODELDQB:
      token = jj_consume_token(ODELDQB);
                                    if (js) { out.append(token.image); }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH:
        case OPROPERTY:
        case OXMODEL:
        case OFILE:
        case OSQL:
        case OANY:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_1;
        }
        OORLToken(out);
      }
      token = jj_consume_token(ODELDQE);
                                    if (js) { out.append(token.image); }
      break;
    case ODELSQB:
      token = jj_consume_token(ODELSQB);
                                    if (js) { out.append(token.image); }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH:
        case OPROPERTY:
        case OXMODEL:
        case OFILE:
        case OSQL:
        case OANY:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_2;
        }
        OORLToken(out);
      }
      token = jj_consume_token(ODELSQE);
                                    if (js) { out.append(token.image); }
      break;
    case ODELBCB:
      token = jj_consume_token(ODELBCB);
                                    if (js) { out.append(token.image); }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH:
        case OPROPERTY:
        case OXMODEL:
        case OFILE:
        case OSQL:
        case OANY:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
        OORLToken(out);
      }
      token = jj_consume_token(ODELBCE);
                                    if (js) { out.append(token.image); }
      break;
    case ODELPAB:
      token = jj_consume_token(ODELPAB);
                                    if (js) { out.append(token.image); }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH:
        case OPROPERTY:
        case OXMODEL:
        case OFILE:
        case OSQL:
        case OANY:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        OORLToken(out);
      }
      token = jj_consume_token(ODELPAE);
                                    if (js) { out.append(token.image); }
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Expression(StringBuilder out) throws ParseException {
                                       Token token=null;
    jj_consume_token(EXPRB);
                             out.append("{*");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELT:
      jj_consume_token(ELT);
                             out.append("<");
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\u005c"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(EGT);
                             out.append(">");
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOPBRK:
      jj_consume_token(EOPBRK);
                             out.append("[");
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\u005c"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(ECLBRK);
                             out.append("]");
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
                             out.append("unicode,evaluate:");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANYEXPR:
      token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELT:
        case EGT:
        case EOPBRK:
        case ECLBRK:
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_7;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELT:
          jj_consume_token(ELT);
                             out.append("<");
          break;
        case EGT:
          jj_consume_token(EGT);
                             out.append(">");
          break;
        case EOPBRK:
          jj_consume_token(EOPBRK);
                             out.append("[");
          break;
        case ECLBRK:
          jj_consume_token(ECLBRK);
                             out.append("]");
          break;
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\u005c"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(EXPRE);
                             out.append("*}");
  }

  final public void Line(StringBuilder out) throws ParseException {
                                 Token token=null;
    Token(out);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCAPE:
      case CONT:
      case CONTPLUS:
      case LNINDT:
      case SEPARATOR:
      case UNICODEESC:
      case WS:
      case SELECT:
      case REQUIRE:
      case SCRIPT:
      case PREPROCESS:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case OORL:
      case BASH:
      case SHELL:
      case SCOPE:
      case JAVASCRIPT:
      case OPERATION:
      case PROGRAM:
      case UNICODE:
      case PROCESS:
      case EVALUATE:
      case CONTROL:
      case CHECK:
      case LOG:
      case PLACEHOLDER:
      case OCP:
      case MULTIITER:
      case MULTITIMES:
      case EQUALS:
      case RECODEBS:
      case RECODE:
      case ENCODING:
      case RECODING:
      case DECORATE:
      case JOIN:
      case EJOIN:
      case CONFIG:
      case ENVIRONMENT:
      case OR:
      case AND:
      case ULT:
      case UGT:
      case UNULLSTRING:
      case UEMPTYSTRING:
      case UNULL:
      case UTRUE:
      case UFALSE:
      case UQUOTE:
      case FORMATDATE:
      case FORMAT:
      case TIME:
      case DATETIME:
      case DATE:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case EXPRB:
      case EXECUTE:
      case BEGINPROC:
      case ENDPROC:
      case BEGINBLK:
      case ENDBLK:
      case CMTB:
      case CMTE:
      case BTICK:
      case BACKSL:
      case NEWLINE:
      case ANY:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                               out.append(token.image);
        break;
      case LNINDT:
        jj_consume_token(LNINDT);
                               out.append(token.image);
        break;
      case ESCAPE:
      case CONT:
      case CONTPLUS:
      case SEPARATOR:
      case UNICODEESC:
      case SELECT:
      case REQUIRE:
      case SCRIPT:
      case PREPROCESS:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case OORL:
      case BASH:
      case SHELL:
      case SCOPE:
      case JAVASCRIPT:
      case OPERATION:
      case PROGRAM:
      case UNICODE:
      case PROCESS:
      case EVALUATE:
      case CONTROL:
      case CHECK:
      case LOG:
      case PLACEHOLDER:
      case OCP:
      case MULTIITER:
      case MULTITIMES:
      case EQUALS:
      case RECODEBS:
      case RECODE:
      case ENCODING:
      case RECODING:
      case DECORATE:
      case JOIN:
      case EJOIN:
      case CONFIG:
      case ENVIRONMENT:
      case OR:
      case AND:
      case ULT:
      case UGT:
      case UNULLSTRING:
      case UEMPTYSTRING:
      case UNULL:
      case UTRUE:
      case UFALSE:
      case UQUOTE:
      case FORMATDATE:
      case FORMAT:
      case TIME:
      case DATETIME:
      case DATE:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case EXPRB:
      case EXECUTE:
      case BEGINPROC:
      case ENDPROC:
      case BEGINBLK:
      case ENDBLK:
      case CMTB:
      case CMTE:
      case BTICK:
      case BACKSL:
      case NEWLINE:
      case ANY:
        Token(out);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void LeadingSpace(StringBuilder out) throws ParseException {
                                         Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      token = jj_consume_token(WS);
                             out.append(token.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNINDT:
        jj_consume_token(LNINDT);
                             out.append("<%|");
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          token = jj_consume_token(WS);
                             out.append(token.image);
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      break;
    case LNINDT:
      jj_consume_token(LNINDT);
                             out.append("<%|");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                             out.append(token.image);
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NewLine(StringBuilder out) throws ParseException {
                                    Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LNCONT:
      jj_consume_token(LNCONT);
                           out.append("\u005c\u005c\u005cn");
      break;
    case LNCONTPLUS:
      jj_consume_token(LNCONTPLUS);
                           out.append("\u005c\u005c+\u005cn");
      break;
    case LN:
      jj_consume_token(LN);
                           out.append("\u005cn");
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String XCUS() throws ParseException {
                  Token token=null;
    StringBuilder out = new StringBuilder();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LNINDT:
    case WS:
      LeadingSpace(out);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCAPE:
    case CONT:
    case CONTPLUS:
    case SEPARATOR:
    case UNICODEESC:
    case SELECT:
    case REQUIRE:
    case SCRIPT:
    case PREPROCESS:
    case CMTBEGIN:
    case CMTEND:
    case EXPRBEGIN:
    case EXPREND:
    case OORL:
    case BASH:
    case SHELL:
    case SCOPE:
    case JAVASCRIPT:
    case OPERATION:
    case PROGRAM:
    case UNICODE:
    case PROCESS:
    case EVALUATE:
    case CONTROL:
    case CHECK:
    case LOG:
    case PLACEHOLDER:
    case OCP:
    case MULTIITER:
    case MULTITIMES:
    case EQUALS:
    case RECODEBS:
    case RECODE:
    case ENCODING:
    case RECODING:
    case DECORATE:
    case JOIN:
    case EJOIN:
    case CONFIG:
    case ENVIRONMENT:
    case OR:
    case AND:
    case ULT:
    case UGT:
    case UNULLSTRING:
    case UEMPTYSTRING:
    case UNULL:
    case UTRUE:
    case UFALSE:
    case UQUOTE:
    case FORMATDATE:
    case FORMAT:
    case TIME:
    case DATETIME:
    case DATE:
    case SIZE:
    case AVERAGE:
    case PRODUCT:
    case SUM:
    case MINIMUM:
    case MAXIMUM:
    case EXPRB:
    case EXECUTE:
    case BEGINPROC:
    case ENDPROC:
    case BEGINBLK:
    case ENDBLK:
    case CMTB:
    case CMTE:
    case BTICK:
    case BACKSL:
    case NEWLINE:
    case ANY:
      Line(out);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNCONT:
      case LNCONTPLUS:
      case LN:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_9;
      }
      NewLine(out);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNINDT:
      case WS:
        LeadingSpace(out);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCAPE:
      case CONT:
      case CONTPLUS:
      case SEPARATOR:
      case UNICODEESC:
      case SELECT:
      case REQUIRE:
      case SCRIPT:
      case PREPROCESS:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case OORL:
      case BASH:
      case SHELL:
      case SCOPE:
      case JAVASCRIPT:
      case OPERATION:
      case PROGRAM:
      case UNICODE:
      case PROCESS:
      case EVALUATE:
      case CONTROL:
      case CHECK:
      case LOG:
      case PLACEHOLDER:
      case OCP:
      case MULTIITER:
      case MULTITIMES:
      case EQUALS:
      case RECODEBS:
      case RECODE:
      case ENCODING:
      case RECODING:
      case DECORATE:
      case JOIN:
      case EJOIN:
      case CONFIG:
      case ENVIRONMENT:
      case OR:
      case AND:
      case ULT:
      case UGT:
      case UNULLSTRING:
      case UEMPTYSTRING:
      case UNULL:
      case UTRUE:
      case UFALSE:
      case UQUOTE:
      case FORMATDATE:
      case FORMAT:
      case TIME:
      case DATETIME:
      case DATE:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case EXPRB:
      case EXECUTE:
      case BEGINPROC:
      case ENDPROC:
      case BEGINBLK:
      case ENDBLK:
      case CMTB:
      case CMTE:
      case BTICK:
      case BACKSL:
      case NEWLINE:
      case ANY:
        Line(out);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
    }
    jj_consume_token(0);
    {if (true) return out.toString();}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public XCUS2ASCIITokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[30];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfffff9b2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffffbf2,0xfffffbf2,0x200,0x40,0x200,0x240,0x40c,0x240,0xfffff9b2,0x40c,0x240,0xfffff9b2,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0xffffffff,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x7fff,0xe0000000,0x20000,0x8000,0xe0000000,0xe0000000,0xe0000000,0xe0000000,0x1e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fff,0x7fff,0x0,0x0,0x0,0x0,0x0,0x0,0x7fff,0x0,0x0,0x7fff,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x7,0x0,0x0,0x7,0x7,0x7,0x7,0x0,0x300,0x300,0x8,0x300,0x300,0x20,0x378,0x378,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public XCUS2ASCII(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public XCUS2ASCII(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new XCUS2ASCIITokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public XCUS2ASCII(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XCUS2ASCIITokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public XCUS2ASCII(XCUS2ASCIITokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(XCUS2ASCIITokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[106];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 30; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 106; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
