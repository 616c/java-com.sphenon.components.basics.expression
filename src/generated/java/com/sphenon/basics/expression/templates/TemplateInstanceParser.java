/* Generated By:JavaCC: Do not edit this line. TemplateInstanceParser.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.basics.expression.templates;

import com.sphenon.basics.context.*;

import java.io.BufferedReader;
import java.io.StringReader;
import java.io.IOException;

public class TemplateInstanceParser implements TemplateInstanceParserConstants {

  static public TemplateInstance parse(CallContext context, String string) throws ParseException {
      return new TemplateInstanceParser(context, string).TemplateInstanceExpression(context);
  }

  public TemplateInstanceParser (CallContext context, String expression) {
      this(new BufferedReader(new StringReader(expression)));
  }

  public String getPosition(CallContext context) {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public String DottedIdentifier() throws ParseException {
                              Token token; Token sep = null; String result; String postfix=null;
    token = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEP:
      sep = jj_consume_token(SEP);
      postfix = DottedIdentifier();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
                                                                     result = token.image + (postfix == null ? "" : (sep.image + postfix));
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String ArrayOrType() throws ParseException {
                         String result;
    result = DottedIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPBRK:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      jj_consume_token(OPBRK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      jj_consume_token(CLBRK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
                                                result += "[]";
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public TemplateInstance TemplateInstance(CallContext context) throws ParseException {
                                                            Token token; String arrayortype; TemplateInstanceArguments list1 = null; TemplateInstanceArguments list2 = null; TemplateInstanceArguments list3 = null;
    arrayortype = ArrayOrType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPMTPL:
      jj_consume_token(OPMTPL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      list1 = TemplateInstanceArguments(context, GenericLevel.MODEL_TEMPLATE);
      jj_consume_token(CLMTPL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPJTPL:
      jj_consume_token(OPJTPL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      list2 = TemplateInstanceArguments(context, GenericLevel.CODE_GENERATOR_TEMPLATE);
      jj_consume_token(CLJTPL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      jj_consume_token(LT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      list3 = TemplateInstanceArguments(context, GenericLevel.IMPLEMENTATION_LANGUAGE_TEMPLATE);
      jj_consume_token(GT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    {if (true) return new TemplateInstance(context, arrayortype, list1, list2, list3);}
    throw new Error("Missing return statement in function");
  }

  final public TemplateInstanceArguments TemplateInstanceArguments(CallContext context, GenericLevel generic_level) throws ParseException {
                                                                                                          Token token; TemplateInstanceArguments result; TemplateInstance argument;
    result = new TemplateInstanceArguments(context, generic_level);
    argument = TemplateInstance(context);
                                                                 result.append(context, argument);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      argument = TemplateInstance(context);
                                                                 result.append(context, argument);
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public TemplateInstance TemplateInstanceExpression(CallContext context) throws ParseException {
                                                                     TemplateInstance result;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    result = TemplateInstance(context);
    jj_consume_token(0);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  public TemplateInstanceParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[17];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x800,0x1000,0x100,0x1000,0x1000,0x1000,0x1000,0x10,0x1000,0x1000,0x4,0x1000,0x1000,0x40,0x400,0x1000,0x1000,};
   }

  public TemplateInstanceParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public TemplateInstanceParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TemplateInstanceParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  public TemplateInstanceParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TemplateInstanceParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  public TemplateInstanceParser(TemplateInstanceParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  public void ReInit(TemplateInstanceParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[14];
    for (int i = 0; i < 14; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 17; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 14; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
